// Generated by CoffeeScript 2.5.1
(function() {
  var flat, isInside, root, subGrid;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  // helper functions -----------------------------------------------------
  flat = function(type, arr) {
    var flatten, m, polygon;
    flatten = function(polygon) {
      return polygon.reduce(function(a, b) {
        return a.concat([[0, 0]].concat(b));
      });
    };
    switch (type) {
      case "Polygon":
        m = flatten(arr);
        break;
      case "MultiPolygon":
        m = flatten((function() {
          var l, len, results;
          results = [];
          for (l = 0, len = arr.length; l < len; l++) {
            polygon = arr[l];
            results.push(flatten(polygon));
          }
          return results;
        })());
    }
    return [[0, 0]].concat(m.concat([[0, 0]]));
  };

  subGrid = function(box, side) {
    var i, j, x, x1, y, y1;
    x = 1 + Math.floor(box[0][0] / side);
    y = 1 + Math.floor(box[0][1] / side);
    x1 = Math.floor(box[1][0] / side);
    y1 = Math.floor(box[1][1] / side);
    if (x1 >= x && y1 >= y) {
      return ((function() {
        var l, ref, ref1, results;
        results = [];
        for (j = l = ref = y, ref1 = y1; (ref <= ref1 ? l <= ref1 : l >= ref1); j = ref <= ref1 ? ++l : --l) {
          results.push((function() {
            var n, ref2, ref3, results1;
            results1 = [];
            for (i = n = ref2 = x, ref3 = x1; (ref2 <= ref3 ? n <= ref3 : n >= ref3); i = ref2 <= ref3 ? ++n : --n) {
              results1.push([i, j]);
            }
            return results1;
          })());
        }
        return results;
      })()).reduce(function(a, b) {
        return a.concat(b);
      });
    } else {
      return [];
    }
  };

  isInside = function(point, vs) {
    var i, inside, intersect, j, l, ref, x, xi, xj, y, yi, yj;
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    x = point[0];
    y = point[1];
    inside = false;
    j = vs.length - 1;
    for (i = l = 0, ref = vs.length - 1; (0 <= ref ? l <= ref : l >= ref); i = 0 <= ref ? ++l : --l) {
      xi = vs[i][0];
      yi = vs[i][1];
      xj = vs[j][0];
      yj = vs[j][1];
      intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) {
        inside = !inside;
      }
      j = i;
    }
    return inside;
  };

  // end helper functions -------------------------------------------------
  root.gridmap = function() {
    var chart, data, features, fill, grid, height, isDensity, key, projection, side, width;
    // ---- Default Values ------------------------------------------------
    projection = void 0; // d3.geo projection
    data = void 0; // d3.map() mapping key to data
    features = void 0; // array of map features
    isDensity = void 0; // set to `true` if data define a density
    side = 10; // side of the cells in pixel
    key = "id"; // name of the attribute mapping features to data
    width = 500;
    height = 500;
    fill = "#343434";
    grid = new Map();
    // --------------------------------------------------------------------
    chart = function(selection) {
      var area, box, c, centroid, coords, dataGrid, density, dots, f, g, h, i, ii, j, k, l, len, len1, len2, map, n, o, path, points, polygon, radius, ref, svg, value, w, x, y;
      w = width;
      h = height;
      path = d3.geoPath().projection(projection);
      radius = d3.scaleLinear().range([0, side / 2 * 0.9]);
      area = new Map();
      centroid = new Map();
      for (l = 0, len = features.length; l < len; l++) {
        f = features[l];
        area.set(f[key], path.area(f) / (w * h));
      }
      svg = selection.append("svg").attr("width", w).attr("height", h).attr("viewBox", "0 0 " + w + " " + h);
      map = svg.append("g");
      map.selectAll("path").data(features).enter().append("path").style("opacity", 0).attr("d", path);
// define the grid
      for (n = 0, len1 = features.length; n < len1; n++) {
        f = features[n];
        g = f.geometry;
        if ((ref = g.type) === "Polygon" || ref === "MultiPolygon") {
          box = path.bounds(f);
          points = subGrid(box, side);
          value = [f[key]];
          if (points.length) {
            polygon = flat(g.type, g.coordinates);
            for (o = 0, len2 = points.length; o < len2; o++) {
              [i, j] = points[o];
              x = side * i;
              y = side * j;
              coords = projection.invert([x, y]);
              ii = isInside(coords, polygon);
              if (ii) {
                grid.set(i + "," + j, {
                  keys: value,
                  x: x,
                  y: y
                });
              }
            }
          } else {
            c = path.centroid(f);
            if (c) {
              centroid.set(f[key], c);
            }
          }
        }
      }
      // add not hitted features to the nearest cell
      centroid.forEach(function(v, k) {
        i = Math.floor(v[0] / side);
        j = Math.floor(v[1] / side);
        try {
          return grid.get(i + "," + j).keys.push(k);
        } catch (error) {}
      });
      density = function(a) {
        var den, num;
        if (isDensity) {
          num = d3.sum((function() {
            var len3, p, results;
            results = [];
            for (p = 0, len3 = a.length; p < len3; p++) {
              j = a[p];
              results.push(data.get(j) * area.get(j));
            }
            return results;
          })());
        } else {
          num = d3.sum((function() {
            var len3, p, results;
            results = [];
            for (p = 0, len3 = a.length; p < len3; p++) {
              j = a[p];
              results.push(data.get(j));
            }
            return results;
          })());
        }
        den = d3.sum((function() {
          var len3, p, results;
          results = [];
          for (p = 0, len3 = a.length; p < len3; p++) {
            j = a[p];
            results.push(area.get(j));
          }
          return results;
        })());
        if (den) {
          return num / den;
        } else {
          return 0;
        }
      };
      dataGrid = (function() {
        var len3, p, ref1, results;
        ref1 = Array.from(grid.values());
        results = [];
        for (p = 0, len3 = ref1.length; p < len3; p++) {
          k = ref1[p];
          if (k.keys.length) {
            results.push({
              value: density(k.keys),
              x: k.x,
              y: k.y
            });
          }
        }
        return results;
      })();
      dots = map.selectAll(".gridmap-dot").data(dataGrid);
      radius.domain([
        0,
        d3.max(dataGrid,
        function(d) {
          return Math.sqrt(d.value);
        })
      ]);
      
      // enter
      return dots.enter().append("circle").attr("class", "gridmap-dot").attr("cx", function(d) {
        return d.x;
      }).attr("cy", function(d) {
        return d.y;
      }).attr("r", function(d) {
        return radius(Math.sqrt(d.value));
      }).style("fill", fill);
    };
    // ---- Getter/Setter Methods -----------------------------------------
    chart.width = function(_) {
      width = _;
      return chart;
    };
    chart.height = function(_) {
      height = _;
      return chart;
    };
    chart.side = function(_) {
      side = _;
      return chart;
    };
    chart.key = function(_) {
      key = _;
      return chart;
    };
    chart.data = function(_) {
      data = _;
      return chart;
    };
    chart.isDensity = function(_) {
      isDensity = _;
      return chart;
    };
    chart.features = function(_) {
      features = _;
      return chart;
    };
    chart.projection = function(_) {
      projection = _;
      return chart;
    };
    chart.fill = function(_) {
      fill = _;
      return chart;
    };
    
    // --------------------------------------------------------------------
    return chart;
  };

}).call(this);
